
@{
    ViewData["Title"] = "Index";
    Layout = "_Layout";
}

<div class="row">
    <div class="col">
        <div class="card" style="margin: 20px;">
            <div class="card-body">
                <h5 class="card-title">Capitulo 1: Controlando el flujo de un programa</h5>
                <h6 class="card-subtitle mb-2 text-muted">Tema 5: Implementar el manejo de exepciones</h6>
                <hr>
                <p class="card-text">
                    <h5>Respuestas</h5>
                    <ul>
                        <li>
                            Esta sección proporciona las soluciones para las tareas incluidas en los experimentos mentales.
                        </li>
                    </ul>
                    <h6>Uso de múltiples tareas</h6>
                    <ul>
                        <li>
                            1. Dividir una aplicación en tareas separadas no es solo algo que haría para aprovechar las ventajas de rendimiento. Las tareas proporcionan un nivel de abstracción muy útil.
                            Una vez que se ha diseñado la comunicación entre las tareas, se puede trabajar en cada una de forma independiente. Particionar una aplicación en tareas puede verse como una
                            extensión natural del diseño basado en componentes.
                        </li>
                        <li>
                            2. Considere un programa que realiza un análisis numérico de un conjunto de datos en particular. Una vez que los datos se han cargado en la memoria, el tiempo que tarda en
                            procesarse está determinado por la velocidad de la CPU. Diríamos que este programa estaba vinculado a la CPU. Si un sistema solo tiene un procesador, la conversión del
                            programa para usar una implementación de subprocesos múltiples no mejoraría la velocidad a la que se procesan los datos. Sin embargo, considere un programa que interactúa
                            continuamente con el sistema de archivos. Diríamos que esta aplicación estaba vinculada a IO (entrada / salida), ya que la velocidad a la que puede funcionar está determinada
                            por el rendimiento del sistema de archivos. Cuando un programa vinculado a IO está activo, con frecuencia no podrá realizar ningún trabajo mientras espera que se completen las
                            transacciones de archivos. Una solución de subprocesos múltiples podría realizar el procesamiento en los momentos en que una tarea estaba esperando que se completara una
                            operación de entrada / salida.
                        </li>
                        <li>
                            3. Una aplicación vinculada a la CPU se beneficiará de un enfoque multitarea si el sistema host tiene más de una CPU. Tenga en cuenta que el programador puede tener que dedicar
                            un poco de esfuerzo a reelaborar la aplicación para permitirle realizar múltiples tareas. Una aplicación que contiene una combinación de tareas vinculadas a la CPU y a la IO
                            puede beneficiarse más de un enfoque de subprocesos múltiples, ya que siempre habrá algo que el procesador pueda hacer.
                        </li>
                        <li>
                            4. La naturaleza asincrónica de una aplicación multiproceso hace que sea muy difícil garantizar que una operación dada se completará dentro de un tiempo específico. Los hilos
                            pueden tener niveles de prioridad, pero estos no son duros y rápidos. Las aplicaciones con requisitos críticos de tiempo no deben implementarse utilizando múltiples
                            subprocesos.
                        </li>
                        <li>
                            5. Al elegir entre tareas e hilos, debe considerar lo que desea lograr. Las tareas son buenas para los procesos en segundo plano. Los subprocesos se pueden usar para procesos
                            en segundo plano, pero también se pueden ejecutar como procesos en primer plano. Las tareas son más fáciles de crear. En esta situación, una tarea tendría más sentido, porque
                            sería más fácil de crear y nunca necesitará operar en primer plano.
                        </li>
                        <li>
                            6. El método WaitAll regresará cuando se hayan completado todas las tareas que se están ejecutando. El método WaitAny volverá cuando se complete la primera de las tareas en
                            ejecución.
                        </li>
                        <li>
                            7. Una tarea de continuación es una tarea que se inicia cuando se completa una tarea existente. Una tarea secundaria es creada por una tarea principal y se ejecuta
                            independientemente de la principal.
                        </li>
                        <li>
                            8. El método WaitAll acepta una lista de referencias de tareas como argumento y regresa cuando todas las tareas se han completado. El método WaitAll no devuelve un resultado.
                            El método WhenAll acepta una lista de referencias de Tarea como argumento y devuelve una Tarea que entrega los resultados devueltos por esas tareas. El método WhenAll se puede
                            esperar, lo que permite su uso en código asincrónico.
                        </li>
                        <li>
                            9. Los métodos que se pueden esperar devuelven una referencia a una tarea. Cuando un programa realiza una espera en un método asincrónico, el método
                            asincrónico regresa inmediatamente. Cuando la tarea devuelta por el método esperado se complete, se completará el resto del método asincrónico. Un buen
                            ejemplo de una situación en la que esto puede usarse con buenos resultados es en las interfaces de usuario. Un método de interfaz de usuario, por ejemplo,
                            el código que implementa un comportamiento cuando se hace clic en un botón en la interfaz de usuario, debe regresar lo más rápido posible. De lo contrario,
                            la interfaz de usuario dejará de responder. Al usar esperar, el controlador de clic de botón puede completarse y regresar, mientras que la acción iniciada
                            por el clic de botón se ejecuta en paralelo.
                        </li>
                        <li>
                            10. Una colección concurrente es aquella que tiene comportamientos que pueden ser utilizados por múltiples procesos al mismo tiempo. Algunas colecciones
                            concurrentes, por ejemplo, ConcurrentDictionary, tienen comportamientos adicionales que permiten que los procesos solo realicen actualizaciones a los datos
                            almacenados en la colección cuando es válido hacerlo.
                        </li>
                        <li>
                            2 Gestión de subprocesos múltiples
                        </li>
                        <li>
                            1- No hay garantía de que surjan las condiciones que podrían causar que una condición de carrera cause un problema. Los retrasos naturales en un sistema
                            pueden significar que los eventos ocurren en un orden que significa que las condiciones de carrera no causan ningún problema. Por ejemplo, si una tarea
                            está escribiendo un archivo en un disco, existe una buena probabilidad de que esta tarea tarde más en completarse que otra que está actualizando la pantalla.
                            Sin embargo, los problemas pueden aparecer repentinamente cuando el usuario compra una unidad de disco más rápida o instala más memoria. Esto podría acelerar
                            la acción de escritura y hacer que la aplicación se vuelva inestable. De hecho, estos síntomas son la mejor manera de diagnosticar problemas como este.
                            La primera pregunta que debe hacerle a un usuario cuyo programa se ha vuelto repentinamente poco confiable es "¿Ha realizado algún cambio en el sistema
                            subyacente?"
                        </li>
                        <li>
                            2. La forma más simple de punto muerto se produce cuando dos tareas están esperando que se desbloqueen entre sí. Los puntos muertos más complejos se pueden
                            distribuir en un mayor número de tareas. Sin embargo, cuando se produce un punto muerto, un programa no se está ejecutando muy rápidamente, de hecho, no está
                            sucediendo nada, todas las tareas se esperan entre sí y la aplicación no está tomando tiempo del procesador.
                        </li>
                        <li>
                            3. Hacer todas las llamadas a métodos en un objeto atómico es un enfoque muy duro y peligroso para lograr la seguridad del hilo. Bien puede hacer que una
                            aplicación sea vulnerable a puntos muertos y también podría eliminar cualquier ventaja de rendimiento que se obtendría mediante el uso de múltiples
                            procesadores. Además, no protege contra problemas causados por el uso de parámetros de referencia a un método.
                        </li>
                        <li>
                            4. Agregar declaraciones de bloqueo alrededor de partes críticas del código sin pensar en lo que el código realmente hace es muy peligroso. Puede conducir
                            a cuellos de botella y puntos muertos de rendimiento. Es muy difícil agregar seguridad de subprocesos a un programa una vez que se ha escrito. La única forma
                            segura que he encontrado de escribir código seguro para subprocesos es diseñarlo de esa manera desde el principio.
                        </li>
                        <li>
                            5. A task can be cancelled “silently”, in which case it will just end. Alternatively, it can be made to generate an exception when cancelled. From a design perspective I tend to regard cancelling a task as an exceptional action and would therefore expect there to be some way of propagating this event through the system so that it can be registered in some way.
                        </li>
                        <li>
                            6. Si utiliza la construcción Monitor para gestionar la entrada en acciones atómicas, es posible que una tarea retenga el control cuando no logra bloquear y entrar una acción
                            atómica. Incluso puede establecer un tiempo de espera agregando un valor de tiempo de espera a una llamada del método TryEnter para intentar ingresar una acción atómica.
                            Por lo tanto, sería posible que un programa reconozca que un bloqueo dado no estuvo disponible durante más de un cierto período de tiempo. Luego podría usar un token de
                            cancelación para intentar detener una tarea que podría haber obtenido el objeto de sincronización. Por supuesto, esto solo funcionaría correctamente si la tarea que está
                            causando el punto muerto está verificando su token de cancelación mientras espera su bloqueo. En otras palabras, sí, sería posible hacer esto, pero implicaría mucho trabajo
                            extra. La mejor manera de evitar puntos muertos es asegurarse de que no estén presentes en el diseño de su sistema.
                        </li>
                        <li>
                            3 Flujo de programa
                        </li>
                        <li>
                            1. Las construcciones de bucle while y do-while difieren en un solo aspecto. La construcción while no ejecutará ningún código si la condición de control es
                            falsa, mientras que la construcción do-while prueba la condición de control al finalizar el ciclo, por lo que el código controlado por él siempre se ejecuta
                            una vez, incluso si la condición de control es falsa al principio. A expensas de un programa un poco más complicado, es posible usar solo una forma de
                            construcción de bucle, ambas se proporcionan para facilitar un poco la vida de los programadores.
                        </li>
                        <li>
                            2. Si se usa una pausa en un bucle, el programa saldrá del bucle en ese punto. También es posible salir de un bucle volviendo del método en el que se declara
                            el bucle. Finalmente, un programa saldrá de un ciclo si arroja una excepción dentro del ciclo.
                        </li>
                        <li>
                            3. Una construcción foreach proporciona una forma muy conveniente de expresar la necesidad de enumerar cada uno de los elementos de una colección. Sin
                            embargo, cada elemento enumerado se proporciona como "solo lectura". Si el programa quiere cambiar el valor de un elemento enumerado, es necesario utilizar
                            un bucle for para acceder a cada elemento. Tenga en cuenta que si la construcción foreach está iterando a través de una colección de tipos de referencia, es
                            perfectamente permisible cambiar las propiedades de cada elemento iterado.
                        </li>
                        <li>
                            4. No existe una versión de cortocircuito del operador exclusivo u porque no es posible determinar si es exclusivo o verdadero simplemente examinando uno de
                            los operandos. Recuerde que una operación exclusiva u devuelve verdadero si los dos operandos son diferentes. No es posible hacer esta determinación
                            simplemente examinando uno de los operandos.
                        </li>
                        <li>
                            5. No. Los operadores de C # tienen comportamientos diferentes según el contexto en el que se utilizan. Los tipos enteros y de coma flotante se mantienen de
                            maneras muy diferentes en la memoria de la computadora. Cuando se utilizan operadores aritméticos entre estos tipos, el compilador seleccionará el operador
                            correcto que se utilizará según el tipo de operandos en la expresión.
                        </li>
                        <li>
                            6. El compilador de C # garantiza que las expresiones se evaluarán de acuerdo con las reglas de precedencia y asociabilidad para los operadores en la
                            expresión. Sin embargo, la secuencia precisa en la que se realizan las operaciones no es algo sobre lo que un programador pueda hacer suposiciones.
                        </li>
                        <li>
                            4 Eventos y devoluciones de llamada
                        </li>
                        <li>
                            1. Un delegado es un tipo que puede referirse a un método en un objeto con una firma particular. Un delegado también puede contener listas de referencias de
                            métodos. Se llama a un delegado exactamente de la misma manera que el método al que puede referirse. Si el delegado contiene una lista de referencias de
                            métodos, cada método se llama sin ningún orden en particular. El tipo base de todos los objetos delegados es la clase Delegado.
                        </li>
                        <li>
                            2. Los delegados pueden asignarse a otros delegados, siempre que tengan la misma firma. Los delegados también se pueden agregar a los suscriptores de un
                            delegado multidifusión.
                        </li>
                        <li>
                            3. Un delegado puede asignarse a sí mismo, pero esto no es algo sensato. Si alguna vez se llama al delegado, el programa entrará en un bucle infinito.
                        </li>
                        <li>
                            4. No hay límite superior, más allá de la capacidad de la estructura de datos en la clase Delegado que contiene referencias a suscriptores.
                        </li>
                        <li>
                            5. El operador lambda (=>) separa los elementos que entran en la expresión (los parámetros de entrada) de la instrucción o bloque de instrucción que
                            implementa el comportamiento de la expresión lambda.
                        </li>
                        <li>
                            6. El código en una expresión lambda puede acceder a las variables declaradas en el código que encierra la expresión lambda. Tenga en cuenta que el código en
                            una expresión lambda no se ejecuta cuando se declara la expresión lambda, una referencia a la expresión lambda puede seguirse mucho más tarde. El compilador
                            de C # generará código que mantiene las variables utilizadas por el código en la expresión lambda incluso si normalmente estarían fuera del alcance en el
                            momento en que se realiza el código en la expresión lambda.
                        </li>
                        <li>
                            5 Excepciones
                        </li>
                        <li>
                            1. Todo depende del contexto de la acción. Si el usuario ingresa la fecha, es razonable que el programa muestre un mensaje de error y solicite que se vuelva
                            a ingresar la fecha. En este caso no se lanzará ninguna excepción. Sin embargo, si la fecha se proporciona a un método que se espera que cree una transacción
                            con esta fecha, es razonable que ese método arroje una excepción si se le da un valor de fecha no válido, ya que no sería significativo para el método generar
                            cualquier cosa. Lanzar una excepción, en lugar de devolver un código de error o un valor nulo, es una forma de garantizar que el programa fallará de manera
                            adecuada y maximiza las posibilidades de que se detecte el error. Desde una perspectiva de diseño, la necesidad de excepciones en esta situación se
                            eliminaría por completo si el método que crea la transacción pasara una estructura DateTime. Esto solo puede contener una fecha válida.
                        </li>
                        <li>
                            2. No. Solo hay una cosa peor que un programa que falla, y ese es un programa que falla silenciosamente. Puede pensar que es una buena idea incluir todo su
                            programa en una construcción de prueba. Esto significaría que el programa nunca fallará debido a una excepción no detectada. Sin embargo, también haría que
                            el programa sea imposible de depurar y propenso a fallar en silencio. Debe tener cuidado de detectar todas las excepciones con las que sabe cómo lidiar y
                            dejar que pasen las restantes para que sean atrapadas por las capas superiores (de manera administrada y diseñada) o propagarse como errores que pueden
                            detectarse y tratado con
                        </li>
                        <li>
                            3. No hay forma de volver a las declaraciones después de que se haya lanzado una excepción. Si un programa quiere volver a intentar el código que puede
                            generar excepciones, este código debe colocarse en un bucle.
                        </li>
                        <li>
                            4. Necesitamos una cláusula final porque el código en la cláusula catch puede regresar de un método o lanzar otras excepciones, en cuyo caso el programa no
                            alcanzará las declaraciones que siguen a la captura. La cláusula final está garantizada para ejecutarse en todas las circunstancias.
                        </li>
                        <li>
                            5. El tipo de excepción estándar proporciona una gran flexibilidad; contiene un diccionario que se puede completar con pares de nombre-valor que describen
                            un error. Los tipos de excepción personalizados pueden ser útiles si ninguno de los tipos de excepción existentes es adecuado para el contexto de excepción.
                            Debido a que se pueden asignar diferentes cláusulas catch a diferentes tipos de excepciones, también hacen que las excepciones sean más fáciles de
                            administrar.
                        </li>
                        <li>
                            Resumen del capítulo
                        </li>
                        <li>
                            ■ El subprocesamiento múltiple permite que una aplicación se componga de varios procesos cooperantes.
                        </li>
                        <li>
                            ■ Cuando crea una aplicación multiproceso, sus comportamientos se distribuyen entre una serie de tareas de cooperación. Las tareas pueden realizarse en
                            paralelo si la computadora host tiene múltiples unidades centrales de procesador (CPU). Una sola CPU ejecutará cada tarea activa por turnos.
                        </li>
                        <li>
                            ■ Crear una aplicación multiproceso puede ser tan simple como tomar un conjunto de acciones existente y usar la biblioteca Task.Parallel o Parallel LINQ
                            para ejecutar las acciones como tareas múltiples.
                        </li>
                        <li>
                            ■ La clase de tarea .NET proporciona una abstracción de alto nivel de una tarea en ejecución. Las tareas pueden devolver valores y las tareas de continuación
                            pueden ejecutarse automáticamente cuando se completa una o más tareas. Las tareas también pueden iniciar tareas secundarias, con la tarea principal retenida
                            hasta que se hayan completado todas las tareas secundarias.
                        </li>
                        <li>
                            ■ La clase .NET Thread proporciona una abstracción de nivel inferior de una tarea en ejecución. Los hilos no pueden devolver resultados, ni puedes crear
                            hilos de continuación. Sin embargo, los subprocesos pueden ejecutarse como procesos en primer plano o en segundo plano. Las tareas solo pueden ejecutarse
                            como procesos en segundo plano.
                        </li>
                        <li>
                            ■ Async y wait hacen que sea muy fácil crear aplicaciones multiproceso. La palabra clave de espera precede a una llamada a un método que ha sido identificado
                            como asíncrono por la palabra clave asíncrona. Un método asincrónico puede devolver una tarea (si el método asincrónico devuelve nulo) o una tarea <tipo>
                                (si el método desea devolver un valor). El compilador generará código que permite que un método asincrónico regrese al llamador cuando se alcanza la palabra
                                clave de espera. Las declaraciones que siguen a la espera se realizarán simultáneamente. Esta forma de trabajar tiene un valor particular cuando se construye
                                la interfaz de usuario para un programa. Una acción asincrónica vinculada a la pulsación de un botón desbloqueará la interfaz de usuario en la primera
                                espera, en lugar de detener la interfaz de usuario hasta que la acción realizada por el botón se haya completado. Una aplicación puede detectar excepciones
                                lanzadas durante llamadas asincrónicas encerrando la acción esperada en un controlador de excepciones, pero esto solo funciona si la acción esperada devuelve
                                un valor. Por esta razón, se deben evitar las llamadas asíncronas anuladas ya que no hay forma de determinar si tuvieron éxito o no.
                        </li>
                        <li>
                            ■ Las clases de colección .NET estándar no son seguras para subprocesos. Esto significa que si varias tareas intentan compartir datos usando una Lista, el
                            contenido de la lista se dañará. .NET Framework proporciona un conjunto de colecciones simultáneas que pueden ser compartidas por múltiples tareas activas.
                            La clase BlockingCollection proporciona un contenedor alrededor de las colecciones concurrentes ConcurrentStack, ConcurrentQueue y ConcurrentBag. Las tareas
                            que utilicen una BlockingCollection se bloquearán (pausarán) si no hay espacio para elementos adicionales o si intentan tomar elementos de una
                            colección vacía. Las colecciones simultáneas proporcionan versiones de "prueba" de métodos para extraer elementos que devuelven si una acción tuvo éxito o
                            no. Esto se debe a que en el tiempo transcurrido entre determinar que hay elementos disponibles y leerlos, es posible que otra tarea haya eliminado los
                            elementos. La clase ConcurrentDictionary proporciona métodos adicionales para la actualización condicional de elementos en el diccionario.
                        </li>
                        <li>
                            ■ Las aplicaciones de subprocesos múltiples son vulnerables a las condiciones de carrera donde las acciones de una tarea en un elemento de datos compartidos
                            no se ejecutan hasta su finalización antes de que esa tarea sea reemplazada por otra.
                        </li>
                        <li>
                            ■ Las condiciones de carrera se pueden abordar haciendo acciones atómicas, ya que siempre se completarán antes de que otra tarea pueda realizar la acción.
                            Esto se logra mediante el uso de objetos de bloqueo. Una tarea reclama el bloqueo y mientras lo tiene, otras tareas que intentan reclamar ese bloqueo e
                            ingresar el código atómico se bloquearán. Esto puede dar como resultado una cola de tareas bloqueadas que esperan que se libere un bloqueo en particular.
                        </li>
                        <li>
                            ■ Se dice que dos tareas que esperan cerraduras entre sí están estancadas o en un abrazo mortal. Los puntos muertos pueden surgir como resultado de un código
                            que espera el acceso a un objeto de bloqueo dentro de una acción atómica. Esto debe abordarse con un buen diseño.
                        </li>
                        <li>
                            ■ El mecanismo del monitor para el bloqueo se puede utilizar con preferencia a la palabra clave de bloqueo si una aplicación se beneficiaría de que las
                            tareas puedan determinar si pueden tener acceso a una acción atómica o no, en lugar de bloquearse tan pronto como intenten adquirir el bloquear.
                        </li>
                        <li>
                            ■ Las acciones simples, como la actualización de una variable en particular, se pueden lograr mediante el uso de operaciones entrelazadas, en lugar de crear
                            bloques de código atómicos.
                        </li>
                        <li>
                            ■ Las variables que pueden ser utilizadas por múltiples procesos pueden marcarse como "volátiles". Esto le indica al compilador que no realice una
                            optimización como el almacenamiento en caché del valor de la variable en un registro del procesador o el cambio del orden de las instrucciones.
                        </li>
                        <li>
                            ■ Las tareas pueden cancelarse mediante el uso de tokens de cancelación. A medida que se ejecuta una tarea, debe verificar el estado del token para
                            determinar si se ha solicitado una cancelación. Esta es una diferencia importante entre una tarea y un hilo. Los hilos pueden ser abortados por otro proceso
                            en cualquier momento. Una tarea puede solicitar que se cancele otra tarea, pero esto solo dará como resultado que ese hilo finalice si el código de la tarea
                            está verificando el token de cancelación. Sin embargo, tenga en cuenta que esto no significa que una tarea activa nunca se pueda eliminar de la memoria, ya
                            que las tareas que se ejecutan en segundo plano se finalizan automáticamente al finalizar el proceso en primer plano que las creó.
                        </li>
                        <li>
                            ■ Los métodos en un objeto deben ser seguros para subprocesos si se van a utilizar en aplicaciones que contienen múltiples tareas. El acceso a los miembros
                            de datos de la clase que contiene el método seguro para subprocesos debe administrarse de manera atómica. Los parámetros pasados ​​al método por referencia son
                            vulnerables a los cambios en los elementos del parámetro que pueden ocurrir mientras el método se está ejecutando.
                        </li>
                        <li>
                            ■ Una construcción while es útil en situaciones en las que desea repetir algo siempre que una condición sea verdadera. Una construcción do-while es útil en
                            situaciones en las que desea hacer algo y luego repetirlo si la acción falla.
                        </li>
                        <li>
                            ■ A para la construcción es una manera fácil de realizar acciones de inicialización, prueba y actualización en un bucle. A para la construcción con frecuencia
                            implica la gestión de un valor de contador, pero esta no es la única forma en que se puede utilizar esta construcción.
                        </li>
                        <li>
                            ■ Se puede usar una construcción foreach para enumerar los elementos de una colección. La colección proporciona un método que proporcionará un enumerador que
                            luego se iterará por la construcción foreach. Los elementos de la colección se proporcionan como de solo lectura.
                        </li>
                        <li>
                            ■ Las clases de colección .NET estándar no son seguras para subprocesos. Esto significa que si varias tareas intentan compartir datos usando una Lista, el
                            contenido de la lista se dañará. .NET Framework proporciona un conjunto de colecciones simultáneas que pueden ser compartidas por múltiples tareas activas.
                            La clase BlockingCollection proporciona un contenedor alrededor de las colecciones concurrentes ConcurrentStack, ConcurrentQueue y ConcurrentBag. Las tareas
                            que utilicen una BlockingCollection se bloquearán (pausarán) si no hay espacio para elementos adicionales o si intentan tomar elementos de una colección
                            vacía. Las colecciones simultáneas proporcionan versiones de "prueba" de métodos para extraer elementos que devuelven si una acción tuvo éxito o no. Esto se
                            debe a que en el tiempo transcurrido entre determinar que hay elementos disponibles y leerlos, es posible que otra tarea haya eliminado los elementos. La
                            clase ConcurrentDictionary proporciona métodos adicionales para la actualización condicional de elementos en el diccionario.
                        </li>
                        <li>
                            ■ Las aplicaciones de subprocesos múltiples son vulnerables a las condiciones de carrera donde las acciones de una tarea en un elemento de datos compartidos
                            no se ejecutan hasta su finalización antes de que esa tarea sea reemplazada por otra.
                        </li>
                        <li>
                            ■ Las condiciones de carrera se pueden abordar haciendo acciones atómicas, ya que siempre se completarán antes de que otra tarea pueda realizar la acción.
                            Esto se logra mediante el uso de objetos de bloqueo. Una tarea reclama el bloqueo y mientras lo tiene, otras tareas que intentan reclamar ese bloqueo e
                            ingresar el código atómico se bloquearán. Esto puede dar como resultado una cola de tareas bloqueadas que esperan que se libere un bloqueo en particular.
                        </li>
                        <li>
                            ■ Se dice que dos tareas que esperan cerraduras entre sí están estancadas o en un abrazo mortal. Los puntos muertos pueden surgir como resultado de un código
                            que espera el acceso a un objeto de bloqueo dentro de una acción atómica. Esto debe abordarse con un buen diseño.
                        </li>
                        <li>
                            ■ El mecanismo del monitor para el bloqueo se puede utilizar con preferencia a la palabra clave de bloqueo si una aplicación se beneficiaría de que las tareas
                            puedan determinar si pueden tener acceso a una acción atómica o no, en lugar de bloquearse tan pronto como intenten adquirir el bloquear.
                        </li>
                        <li>
                            ■ Las acciones simples, como la actualización de una variable en particular, se pueden lograr mediante el uso de operaciones entrelazadas, en lugar de crear
                            bloques de código atómicos.
                        </li>
                        <li>
                            ■ Las variables que pueden ser utilizadas por múltiples procesos pueden marcarse como "volátiles". Esto le indica al compilador que no realice una
                            optimización como el almacenamiento en caché del valor de la variable en un registro del procesador o el cambio del orden de las instrucciones.
                        </li>
                        <li>
                            ■ Las tareas pueden cancelarse mediante el uso de tokens de cancelación. A medida que se ejecuta una tarea, debe verificar el estado del token para determinar
                            si se ha solicitado una cancelación. Esta es una diferencia importante entre una tarea y un hilo. Los hilos pueden ser abortados por otro proceso en cualquier
                            momento. Una tarea puede solicitar que se cancele otra tarea, pero esto solo dará como resultado que ese hilo finalice si el código de la tarea está verificando el token de cancelación. Sin embargo, tenga en cuenta que esto no significa que una tarea activa nunca se pueda eliminar de la memoria, ya que las tareas que se ejecutan en segundo plano se finalizan automáticamente al finalizar el proceso en primer plano que las creó.
                        </li>
                        <li>
                            ■ Los métodos en un objeto deben ser seguros para subprocesos si se van a utilizar en aplicaciones que contienen múltiples tareas. El acceso a los miembros de
                            datos de la clase que contiene el método seguro para subprocesos debe administrarse de manera atómica. Los parámetros pasados ​​al método por referencia son
                            vulnerables a los cambios en los elementos del parámetro que pueden ocurrir mientras el método se está ejecutando.
                        </li>
                        <li>
                            ■ Una construcción while es útil en situaciones en las que desea repetir algo siempre que una condición sea verdadera. Una construcción do-while es útil en
                            situaciones en las que desea hacer algo y luego repetirlo si la acción falla.
                        </li>
                        <li>
                            ■ A para la construcción es una manera fácil de realizar acciones de inicialización, prueba y actualización en un bucle. A para la construcción con frecuencia
                            implica la gestión de un valor de contador, pero esta no es la única forma en que se puede utilizar esta construcción.
                        </li>
                        <li>
                            ■ Se puede usar una construcción foreach para enumerar los elementos de una colección. La colección proporciona un método que proporcionará un enumerador que
                            luego se iterará por la construcción foreach. Los elementos de la colección se proporcionan como de solo lectura.
                        </li>
                        <li>
                            ■ La declaración de interrupción permite que un programa salga de un ciclo inmediatamente. Una gran cantidad de interrupciones en un bucle puede dificultar
                            discernir las circunstancias en las que salió el bucle. También se puede salir de un bucle al regresar del método en el que se está ejecutando y cuando el
                            código del bucle arroja una excepción que no queda atrapada en el bucle.
                        </li>
                        <li>
                            ■ La instrucción continue permite que un programa regrese a la "parte superior" de un bucle y repita el bucle sin pasar por el código del bucle. Tenga en
                            cuenta que cualquier comportamiento de actualización y prueba se realizará cuando se ejecute una instrucción de continuación.
                        </li>
                        <li>
                            ■ Una construcción if permite la ejecución condicional de una declaración o bloque de declaraciones. Si las construcciones están controladas por una expresión
                            lógica y pueden ser seguidas por una cláusula else que identifica la declaración que se realizará si la condición es falsa. Si las condiciones se pueden
                            anidar, una parte de otra de una construcción if siempre se une al if más "cercano".
                        </li>
                        <li>
                            ■ Las expresiones lógicas se evalúan como verdaderas o falsas. Las variables se pueden comparar utilizando operadores relacionales y de igualdad. Los valores
                            lógicos se pueden combinar usando y, o y exclusivos u operadores. El operador y y el operador o tienen versiones de "cortocircuito" que solo se evalúan hasta
                            el punto donde se puede determinar el valor del resultado de la expresión.
                        </li>
                        <li>
                            ■ La construcción del interruptor permite la selección de un comportamiento dado del valor de un valor de control que puede ser un entero, una cadena o un
                            carácter. Se puede especificar un comportamiento predeterminado si el valor de control no coincide con ninguna de las selecciones.
                        </li>
                        <li>
                            ■ Una expresión contiene operandos y operadores. Los operandos son valores literales o variables. Los operadores tienen prioridad y asociabilidad que
                            determinan el punto en que se aplica el operador durante la evaluación de la expresión.
                        </li>
                        <li>
                            ■ Los programas C # pueden usar delegados para crear variables que pueden servir como referencias a métodos en objetos. Un objeto que desee recibir
                            notificaciones de un editor puede usar un delegado para especificar un método para que lo llame el editor del evento. Un solo delegado de editor realiza
                            llamadas a sus suscriptores, cada uno de los cuales ha proporcionado un delegado.
                        </li>
                        <li>
                            ■ La palabra clave de evento permite que un delegado se use de manera segura y las clases EventArgs describen un patrón que se usa en .NET para permitir que
                            los eventos entreguen datos a un suscriptor.
                        </li>
                        <li>
                            ■ Los delegados también pueden usarse como referencias a métodos individuales. Un delegado que hace referencia a un método puede considerarse como un dato que
                            describe una acción.
                        </li>
                        <li>
                            ■ Una expresión lambda permite que una acción se exprese directamente y proporciona una forma abreviada conveniente al escribir código. El tipo de parámetros
                            y el valor devuelto por una expresión lambda se infieren del contexto de la llamada.
                        </li>
                        <li>
                            ■ Un programa genera una excepción para indicar una situación en la que el programa no puede continuar su funcionamiento normal. La ejecución se transfiere
                            de las declaraciones que se ejecutan en un bloque de código try a un controlador de excepciones en un bloque catch, que se escribió para tratar con la
                            excepción. Una excepción que se genera en el código que no está dentro de una construcción de prueba hará que el subproceso en ejecución finalice.
                        </li>
                        <li>
                            ■ Un último elemento se puede utilizar en una construcción de prueba para especificar el código que siempre se ejecutará.
                        </li>
                        <li>
                            ■ Un programa genera una excepción al crear una nueva instancia de excepción y luego utiliza la palabra clave throw para generarla. Todos los objetos de
                            excepción se derivan de la clase Excepción. Hay una gran cantidad de tipos de excepción que se usan en las bibliotecas .NET para describir condiciones de
                            error; un programador también puede crear sus propios tipos de excepción que contienen su propia información específica de error.
                        </li>
                        <li>
                            ■ Un objeto de excepción contiene información que describe el error, incluida una "traza de pila" que indica el punto en el origen del programa donde se
                            produce la excepción. Una excepción también puede contener una referencia de excepción interna para que una nueva excepción se pueda envolver alrededor de una
                            que se ha detectado, antes de pasar la excepción a otra capa de administración de excepciones.
                        </li>
                    </ul>
                </p>
            </div>
        </div>
    </div>
</div>